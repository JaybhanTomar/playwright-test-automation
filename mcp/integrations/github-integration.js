/**
 * MCP GitHub Integration
 * Integrates MCP with GitHub for automated issue creation, PR comments, and CI/CD
 */

const { Octokit } = require('@octokit/rest');
const fs = require('fs');
const path = require('path');
const mcpConfig = require('../config/mcp-config');
const mcpLogger = require('../utils/mcp-logger');

class GitHubIntegration {
  constructor() {
    this.config = mcpConfig.get('github');
    this.logger = mcpLogger;
    this.octokit = null;
    
    if (this.config.enabled && this.config.token) {
      this.octokit = new Octokit({
        auth: this.config.token
      });
    }
  }

  isEnabled() {
    return this.config.enabled && this.octokit;
  }

  async createIssueForFailure(testFile, error, analysis) {
    if (!this.isEnabled() || !this.config.createIssues) {
      return null;
    }

    try {
      const title = `Test Failure: ${path.basename(testFile)} - ${error.message.substring(0, 50)}...`;
      
      const body = this.generateIssueBody(testFile, error, analysis);
      
      const issue = await this.octokit.rest.issues.create({
        owner: this.config.owner,
        repo: this.config.repo,
        title,
        body,
        labels: ['bug', 'test-failure', 'mcp-generated']
      });

      this.logger.success(`Created GitHub issue for test failure: ${issue.data.html_url}`);
      return issue.data;
    } catch (error) {
      this.logger.error('Failed to create GitHub issue', error);
      return null;
    }
  }

  generateIssueBody(testFile, error, analysis) {
    return `## 🚨 Test Failure Report

**Test File:** \`${testFile}\`
**Error:** ${error.message}
**Timestamp:** ${new Date().toISOString()}

### 🔍 MCP Analysis
${analysis || 'No analysis available'}

### 📊 Environment
- **Environment:** ${mcpConfig.get('project.defaultEnvironment')}
- **AI Model:** ${mcpConfig.get('ai.model')}
- **Branch:** ${this.config.branch}

### 🛠️ Reproduction Steps
1. Run: \`npm run mcp:test ${testFile}\`
2. Check logs in: \`logs/mcp/\`
3. Review analysis in: \`test-results/mcp-analysis/\`

### 📋 Next Steps
- [ ] Review MCP analysis suggestions
- [ ] Apply recommended fixes
- [ ] Re-run test to verify fix
- [ ] Update test if needed

---
*This issue was automatically created by MCP (Model Context Protocol)*`;
  }

  async commentOnPR(prNumber, testResults) {
    if (!this.isEnabled() || !this.config.commentOnPRs) {
      return null;
    }

    try {
      const comment = this.generatePRComment(testResults);
      
      const result = await this.octokit.rest.issues.createComment({
        owner: this.config.owner,
        repo: this.config.repo,
        issue_number: prNumber,
        body: comment
      });

      this.logger.success(`Added MCP test comment to PR #${prNumber}`);
      return result.data;
    } catch (error) {
      this.logger.error('Failed to comment on PR', error);
      return null;
    }
  }

  generatePRComment(testResults) {
    const { passed, failed, total, duration, flakyTests, performance } = testResults;
    
    let comment = `## 🤖 MCP Test Results\n\n`;
    
    // Test Summary
    comment += `### 📊 Test Summary\n`;
    comment += `- **Total Tests:** ${total}\n`;
    comment += `- **Passed:** ${passed} ✅\n`;
    comment += `- **Failed:** ${failed} ${failed > 0 ? '❌' : ''}\n`;
    comment += `- **Duration:** ${duration}ms\n`;
    comment += `- **Success Rate:** ${((passed / total) * 100).toFixed(1)}%\n\n`;

    // Performance Analysis
    if (performance) {
      comment += `### ⚡ Performance Analysis\n`;
      comment += `- **Average Duration:** ${performance.averageDuration}ms\n`;
      comment += `- **Slowest Test:** ${performance.slowestTest} (${performance.slowestDuration}ms)\n`;
      if (performance.slowTests.length > 0) {
        comment += `- **Slow Tests:** ${performance.slowTests.length} tests exceeded threshold\n`;
      }
      comment += `\n`;
    }

    // Flaky Tests
    if (flakyTests && flakyTests.length > 0) {
      comment += `### 🔄 Flaky Tests Detected\n`;
      flakyTests.forEach(test => {
        comment += `- **${test.name}:** ${test.failureRate}% failure rate\n`;
      });
      comment += `\n`;
    }

    // Recommendations
    comment += `### 💡 MCP Recommendations\n`;
    if (failed > 0) {
      comment += `- Review failure analysis in \`test-results/mcp-analysis/\`\n`;
      comment += `- Check MCP logs for detailed error information\n`;
    }
    if (flakyTests && flakyTests.length > 0) {
      comment += `- Address flaky tests to improve reliability\n`;
    }
    if (performance && performance.slowTests.length > 0) {
      comment += `- Optimize slow tests for better performance\n`;
    }
    
    comment += `\n---\n*Generated by MCP (Model Context Protocol)*`;
    
    return comment;
  }

  async createPRForFix(testFile, fix, analysis) {
    if (!this.isEnabled() || !this.config.createPRs) {
      return null;
    }

    try {
      const branchName = `mcp-fix-${path.basename(testFile, '.js')}-${Date.now()}`;
      const title = `🤖 MCP Fix: ${path.basename(testFile)}`;
      
      // Create branch
      const mainBranch = await this.octokit.rest.repos.getBranch({
        owner: this.config.owner,
        repo: this.config.repo,
        branch: this.config.branch
      });

      await this.octokit.rest.git.createRef({
        owner: this.config.owner,
        repo: this.config.repo,
        ref: `refs/heads/${branchName}`,
        sha: mainBranch.data.commit.sha
      });

      // Apply fix (this would need to be implemented based on the fix type)
      // For now, we'll create a PR with the analysis and recommendations
      
      const body = this.generatePRBody(testFile, fix, analysis);
      
      const pr = await this.octokit.rest.pulls.create({
        owner: this.config.owner,
        repo: this.config.repo,
        title,
        body,
        head: branchName,
        base: this.config.branch
      });

      this.logger.success(`Created PR for MCP fix: ${pr.data.html_url}`);
      return pr.data;
    } catch (error) {
      this.logger.error('Failed to create PR for fix', error);
      return null;
    }
  }

  generatePRBody(testFile, fix, analysis) {
    return `## 🤖 MCP Automated Fix

**Test File:** \`${testFile}\`
**Fix Type:** ${fix.type}
**Timestamp:** ${new Date().toISOString()}

### 🔍 Analysis
${analysis}

### 🛠️ Applied Fix
${fix.description}

### 📋 Changes Made
${fix.changes.map(change => `- ${change}`).join('\n')}

### ✅ Verification
- [ ] Test passes after fix
- [ ] No regression in other tests
- [ ] Performance impact acceptable

---
*This PR was automatically created by MCP (Model Context Protocol)*`;
  }

  async getOpenIssues(labels = ['test-failure', 'mcp-generated']) {
    if (!this.isEnabled()) {
      return [];
    }

    try {
      const issues = await this.octokit.rest.issues.listForRepo({
        owner: this.config.owner,
        repo: this.config.repo,
        labels: labels.join(','),
        state: 'open'
      });

      return issues.data;
    } catch (error) {
      this.logger.error('Failed to get open issues', error);
      return [];
    }
  }

  async closeIssueIfFixed(testFile, testPassed) {
    if (!this.isEnabled() || !testPassed) {
      return null;
    }

    try {
      const issues = await this.getOpenIssues();
      const relatedIssue = issues.find(issue => 
        issue.title.includes(path.basename(testFile))
      );

      if (relatedIssue) {
        await this.octokit.rest.issues.update({
          owner: this.config.owner,
          repo: this.config.repo,
          issue_number: relatedIssue.number,
          state: 'closed'
        });

        await this.octokit.rest.issues.createComment({
          owner: this.config.owner,
          repo: this.config.repo,
          issue_number: relatedIssue.number,
          body: `✅ Test is now passing. Issue automatically closed by MCP.`
        });

        this.logger.success(`Closed GitHub issue #${relatedIssue.number} - test now passing`);
        return relatedIssue;
      }
    } catch (error) {
      this.logger.error('Failed to close issue', error);
    }

    return null;
  }

  async syncTestResults(testResults) {
    if (!this.isEnabled()) {
      return;
    }

    this.logger.info('Syncing test results with GitHub');

    // Create issues for new failures
    if (testResults.failures) {
      for (const failure of testResults.failures) {
        await this.createIssueForFailure(failure.testFile, failure.error, failure.analysis);
      }
    }

    // Close issues for fixed tests
    if (testResults.fixed) {
      for (const fixed of testResults.fixed) {
        await this.closeIssueIfFixed(fixed.testFile, true);
      }
    }

    // Comment on current PR if in CI
    const prNumber = process.env.GITHUB_PR_NUMBER || process.env.PR_NUMBER;
    if (prNumber) {
      await this.commentOnPR(parseInt(prNumber), testResults);
    }
  }

  // Get repository information
  async getRepoInfo() {
    if (!this.isEnabled()) {
      return null;
    }

    try {
      const repo = await this.octokit.rest.repos.get({
        owner: this.config.owner,
        repo: this.config.repo
      });

      return {
        name: repo.data.name,
        fullName: repo.data.full_name,
        url: repo.data.html_url,
        defaultBranch: repo.data.default_branch,
        openIssues: repo.data.open_issues_count
      };
    } catch (error) {
      this.logger.error('Failed to get repo info', error);
      return null;
    }
  }
}

module.exports = GitHubIntegration;
